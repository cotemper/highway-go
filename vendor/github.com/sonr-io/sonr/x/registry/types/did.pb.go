// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: registry/did.proto

package types

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NetworkType is the type of network the DID is on.
type NetworkType int32

const (
	// Unspecified is the default value. Gets converted to "did:sonr:".
	NetworkType_NETWORK_TYPE_UNSPECIFIED NetworkType = 0
	// Mainnet is the main network. It prefix is "did:sonr:" or "did:sonr:mainnet:".
	NetworkType_NETWORK_TYPE_MAINNET NetworkType = 1
	// Testnet is the deployed test network. It's prefix is "did:sonr:testnet:".
	NetworkType_NETWORK_TYPE_TESTNET NetworkType = 2
	// Devnet is the localhost test network. It's prefix is "did:sonr:devnet:".
	NetworkType_NETWORK_TYPE_DEVNET NetworkType = 3
)

var NetworkType_name = map[int32]string{
	0: "NETWORK_TYPE_UNSPECIFIED",
	1: "NETWORK_TYPE_MAINNET",
	2: "NETWORK_TYPE_TESTNET",
	3: "NETWORK_TYPE_DEVNET",
}

var NetworkType_value = map[string]int32{
	"NETWORK_TYPE_UNSPECIFIED": 0,
	"NETWORK_TYPE_MAINNET":     1,
	"NETWORK_TYPE_TESTNET":     2,
	"NETWORK_TYPE_DEVNET":      3,
}

func (x NetworkType) String() string {
	return proto.EnumName(NetworkType_name, int32(x))
}

func (NetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{0}
}

// ServiceProtocol are core modules that can be installed on custom services on the Sonr network.
type ServiceProtocol int32

const (
	// SERVICE_PROTOCOL_UNSPECIFIED is the default value.
	ServiceProtocol_SERVICE_PROTOCOL_UNSPECIFIED ServiceProtocol = 0
	// SERVICE_PROTOCOL_BUCKETS is the module that provides the ability to store and retrieve data.
	ServiceProtocol_SERVICE_PROTOCOL_BUCKETS ServiceProtocol = 1
	// SERVICE_PROTOCOL_CHANNEL is the module that provides the ability to communicate with other services.
	ServiceProtocol_SERVICE_PROTOCOL_CHANNEL ServiceProtocol = 2
	// SERVICE_PROTOCOL_OBJECTS is the module that provides the ability to create new schemas for data on the network.
	ServiceProtocol_SERVICE_PROTOCOL_OBJECTS ServiceProtocol = 3
	// SERVICE_PROTOCOL_FUNCTIONS is the module that provides the ability to create new functions for data on the network.
	ServiceProtocol_SERVICE_PROTOCOL_FUNCTIONS ServiceProtocol = 4
)

var ServiceProtocol_name = map[int32]string{
	0: "SERVICE_PROTOCOL_UNSPECIFIED",
	1: "SERVICE_PROTOCOL_BUCKETS",
	2: "SERVICE_PROTOCOL_CHANNEL",
	3: "SERVICE_PROTOCOL_OBJECTS",
	4: "SERVICE_PROTOCOL_FUNCTIONS",
}

var ServiceProtocol_value = map[string]int32{
	"SERVICE_PROTOCOL_UNSPECIFIED": 0,
	"SERVICE_PROTOCOL_BUCKETS":     1,
	"SERVICE_PROTOCOL_CHANNEL":     2,
	"SERVICE_PROTOCOL_OBJECTS":     3,
	"SERVICE_PROTOCOL_FUNCTIONS":   4,
}

func (x ServiceProtocol) String() string {
	return proto.EnumName(ServiceProtocol_name, int32(x))
}

func (ServiceProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{1}
}

// ServiceType is the type of service that is being registered.
type ServiceType int32

const (
	// SERVICE_TYPE_UNSPECIFIED is the default value.
	ServiceType_SERVICE_TYPE_UNSPECIFIED ServiceType = 0
	// SERVICE_TYPE_DID_COMM_MESSAGING is the realtime communication on the sonr network.
	ServiceType_SERVICE_TYPE_DID_COMM_MESSAGING ServiceType = 1
	// SERVICE_TYPE_LINKED_DOMAINS is for linking a URL to an endpoint.
	ServiceType_SERVICE_TYPE_LINKED_DOMAINS ServiceType = 2
	// SERVICE_TYPE_SONR is the type of service that is a DApp.
	ServiceType_SERVICE_TYPE_SONR ServiceType = 3
	// SERVICE_TYPE_DATA_VAULT is the type of service for IPFS encrypted storage.
	ServiceType_SERVICE_TYPE_DATA_VAULT ServiceType = 4
)

var ServiceType_name = map[int32]string{
	0: "SERVICE_TYPE_UNSPECIFIED",
	1: "SERVICE_TYPE_DID_COMM_MESSAGING",
	2: "SERVICE_TYPE_LINKED_DOMAINS",
	3: "SERVICE_TYPE_SONR",
	4: "SERVICE_TYPE_DATA_VAULT",
}

var ServiceType_value = map[string]int32{
	"SERVICE_TYPE_UNSPECIFIED":        0,
	"SERVICE_TYPE_DID_COMM_MESSAGING": 1,
	"SERVICE_TYPE_LINKED_DOMAINS":     2,
	"SERVICE_TYPE_SONR":               3,
	"SERVICE_TYPE_DATA_VAULT":         4,
}

func (x ServiceType) String() string {
	return proto.EnumName(ServiceType_name, int32(x))
}

func (ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{2}
}

// Type is the type of the verification method.
type VerificationMethod_Type int32

const (
	// TYPE_UNSPECIFIED is the default value.
	VerificationMethod_TYPE_UNSPECIFIED VerificationMethod_Type = 0
	// TYPE_ECDSA_SECP256K1 represents the Ed25519VerificationKey2018 key type.
	VerificationMethod_TYPE_ECDSA_SECP256K1 VerificationMethod_Type = 1
	// TYPE_X25519 represents the X25519KeyAgreementKey2019 key type.
	VerificationMethod_TYPE_X25519 VerificationMethod_Type = 2
	// TYPE_ED25519 represents the Ed25519VerificationKey2018 key type.
	VerificationMethod_TYPE_ED25519 VerificationMethod_Type = 3
	// TYPE_BLS_12381_G1 represents the Bls12381G1Key2020 key type
	VerificationMethod_TYPE_BLS_12381_G1 VerificationMethod_Type = 4
	// TYPE_BLS_12381_G2 represents the Bls12381G2Key2020 key type
	VerificationMethod_TYPE_BLS_12381_G2 VerificationMethod_Type = 5
	// TYPE_RSA represents the RsaVerificationKey2018 key type.
	VerificationMethod_TYPE_RSA VerificationMethod_Type = 6
	// TYPE_JSON_WEB_KEY_2020 represents the VerifiableCondition2021 key type.
	VerificationMethod_TYPE_JSON_WEB_KEY_2020 VerificationMethod_Type = 7
)

var VerificationMethod_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "TYPE_ECDSA_SECP256K1",
	2: "TYPE_X25519",
	3: "TYPE_ED25519",
	4: "TYPE_BLS_12381_G1",
	5: "TYPE_BLS_12381_G2",
	6: "TYPE_RSA",
	7: "TYPE_JSON_WEB_KEY_2020",
}

var VerificationMethod_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED":       0,
	"TYPE_ECDSA_SECP256K1":   1,
	"TYPE_X25519":            2,
	"TYPE_ED25519":           3,
	"TYPE_BLS_12381_G1":      4,
	"TYPE_BLS_12381_G2":      5,
	"TYPE_RSA":               6,
	"TYPE_JSON_WEB_KEY_2020": 7,
}

func (x VerificationMethod_Type) String() string {
	return proto.EnumName(VerificationMethod_Type_name, int32(x))
}

func (VerificationMethod_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{4, 0}
}

// Did represents a string that has been parsed and validated as a DID. The parts are stored
// in the individual fields.
type Did struct {
	// Method is the method used to create the DID. For the Sonr network it is "sonr".
	Method string `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	// Network is the network the DID is on. For testnet it is "testnet". i.e "did:sonr:testnet:".
	Network string `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	// id is the trailing identifier after the network. i.e. "did:sonr:testnet:abc123"
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// Paths is a list of paths that the DID is valid for. This is used to identify the Service.
	Paths []string `protobuf:"bytes,4,rep,name=paths,proto3" json:"paths,omitempty"`
	// Query is the query string that was used to create the DID. This is followed by a '?'.
	Query string `protobuf:"bytes,5,opt,name=query,proto3" json:"query,omitempty"`
	// Fragment is the fragment string that was used to create the DID. This is followed by a '#'.
	Fragment string `protobuf:"bytes,6,opt,name=fragment,proto3" json:"fragment,omitempty"`
}

func (m *Did) Reset()         { *m = Did{} }
func (m *Did) String() string { return proto.CompactTextString(m) }
func (*Did) ProtoMessage()    {}
func (*Did) Descriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{0}
}
func (m *Did) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Did) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Did.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Did) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Did.Merge(m, src)
}
func (m *Did) XXX_Size() int {
	return m.Size()
}
func (m *Did) XXX_DiscardUnknown() {
	xxx_messageInfo_Did.DiscardUnknown(m)
}

var xxx_messageInfo_Did proto.InternalMessageInfo

func (m *Did) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *Did) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *Did) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Did) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *Did) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *Did) GetFragment() string {
	if m != nil {
		return m.Fragment
	}
	return ""
}

// DidDocument is the document that describes a DID. This document is stored on the blockchain.
type DidDocument struct {
	// Context is the context of the DID document. This is used to identify the Service.
	Context []string `protobuf:"bytes,1,rep,name=context,proto3" json:"context,omitempty"`
	// Id is the DID of the document.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Controller is the DID of the controller of the document. This will be the individual user devices and mailboxes.
	Controller []string `protobuf:"bytes,3,rep,name=controller,proto3" json:"controller,omitempty"`
	// VerificationMethod is the list of verification methods for the user.
	VerificationMethod []*VerificationMethod `protobuf:"bytes,4,rep,name=verification_method,json=verificationMethod,proto3" json:"verification_method,omitempty"`
	// Authentication is the list of authentication methods for the user.
	Authentication []string `protobuf:"bytes,5,rep,name=authentication,proto3" json:"authentication,omitempty"`
	// AssertionMethod is the list of assertion methods for the user.
	AssertionMethod []string `protobuf:"bytes,6,rep,name=assertion_method,json=assertionMethod,proto3" json:"assertion_method,omitempty"`
	// CapabilityInvocation is the list of capability invocation methods for the user.
	CapabilityInvocation []string `protobuf:"bytes,7,rep,name=capability_invocation,json=capabilityInvocation,proto3" json:"capability_invocation,omitempty"`
	// CapabilityDelegation is the list of capability delegation methods for the user.
	CapabilityDelegation []string `protobuf:"bytes,8,rep,name=capability_delegation,json=capabilityDelegation,proto3" json:"capability_delegation,omitempty"`
	// KeyAgreement is the list of key agreement methods for the user.
	KeyAgreement []string `protobuf:"bytes,9,rep,name=key_agreement,json=keyAgreement,proto3" json:"key_agreement,omitempty"`
	// Service is the list of services or DApps that the user has access to.
	Service []*Service `protobuf:"bytes,10,rep,name=service,proto3" json:"service,omitempty"`
	// AlsoKnownAs is the list of ".snr" aliases for the user.
	AlsoKnownAs []string `protobuf:"bytes,11,rep,name=also_known_as,json=alsoKnownAs,proto3" json:"also_known_as,omitempty"`
	// Metadata is the metadata of the service.
	Metadata map[string]string `protobuf:"bytes,12,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DidDocument) Reset()         { *m = DidDocument{} }
func (m *DidDocument) String() string { return proto.CompactTextString(m) }
func (*DidDocument) ProtoMessage()    {}
func (*DidDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{1}
}
func (m *DidDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DidDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DidDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DidDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DidDocument.Merge(m, src)
}
func (m *DidDocument) XXX_Size() int {
	return m.Size()
}
func (m *DidDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_DidDocument.DiscardUnknown(m)
}

var xxx_messageInfo_DidDocument proto.InternalMessageInfo

func (m *DidDocument) GetContext() []string {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DidDocument) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DidDocument) GetController() []string {
	if m != nil {
		return m.Controller
	}
	return nil
}

func (m *DidDocument) GetVerificationMethod() []*VerificationMethod {
	if m != nil {
		return m.VerificationMethod
	}
	return nil
}

func (m *DidDocument) GetAuthentication() []string {
	if m != nil {
		return m.Authentication
	}
	return nil
}

func (m *DidDocument) GetAssertionMethod() []string {
	if m != nil {
		return m.AssertionMethod
	}
	return nil
}

func (m *DidDocument) GetCapabilityInvocation() []string {
	if m != nil {
		return m.CapabilityInvocation
	}
	return nil
}

func (m *DidDocument) GetCapabilityDelegation() []string {
	if m != nil {
		return m.CapabilityDelegation
	}
	return nil
}

func (m *DidDocument) GetKeyAgreement() []string {
	if m != nil {
		return m.KeyAgreement
	}
	return nil
}

func (m *DidDocument) GetService() []*Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *DidDocument) GetAlsoKnownAs() []string {
	if m != nil {
		return m.AlsoKnownAs
	}
	return nil
}

func (m *DidDocument) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Service is a Application that runs on the Sonr network.
type Service struct {
	// ID is the DID of the service.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Type is the type of the service.
	Type ServiceType `protobuf:"varint,2,opt,name=type,proto3,enum=sonrio.sonr.registry.ServiceType" json:"type,omitempty"`
	// ServiceEndpoint is the endpoint of the service.
	ServiceEndpoint *ServiceEndpoint `protobuf:"bytes,3,opt,name=service_endpoint,json=serviceEndpoint,proto3" json:"service_endpoint,omitempty"`
	// Metadata is the metadata of the service.
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{2}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Service) GetType() ServiceType {
	if m != nil {
		return m.Type
	}
	return ServiceType_SERVICE_TYPE_UNSPECIFIED
}

func (m *Service) GetServiceEndpoint() *ServiceEndpoint {
	if m != nil {
		return m.ServiceEndpoint
	}
	return nil
}

func (m *Service) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// ServiceEndpoint is the endpoint of the service.
type ServiceEndpoint struct {
	// TransportType is the type of transport used to connect to the service.
	TransportType string `protobuf:"bytes,1,opt,name=transport_type,json=transportType,proto3" json:"transport_type,omitempty"`
	// Network is the network the service is on.
	Network string `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	// SupportedProtocols is the list of protocols supported by the service.
	// (e.g. "channels", "buckets", "objects", "storage")
	SupportedProtocols []ServiceProtocol `protobuf:"varint,3,rep,packed,name=supported_protocols,json=supportedProtocols,proto3,enum=sonrio.sonr.registry.ServiceProtocol" json:"supported_protocols,omitempty"`
	// RoutingKeys is the list of routing keys that the service supports.
	RoutingKeys []string `protobuf:"bytes,4,rep,name=routing_keys,json=routingKeys,proto3" json:"routing_keys,omitempty"`
}

func (m *ServiceEndpoint) Reset()         { *m = ServiceEndpoint{} }
func (m *ServiceEndpoint) String() string { return proto.CompactTextString(m) }
func (*ServiceEndpoint) ProtoMessage()    {}
func (*ServiceEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{3}
}
func (m *ServiceEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceEndpoint.Merge(m, src)
}
func (m *ServiceEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *ServiceEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceEndpoint proto.InternalMessageInfo

func (m *ServiceEndpoint) GetTransportType() string {
	if m != nil {
		return m.TransportType
	}
	return ""
}

func (m *ServiceEndpoint) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *ServiceEndpoint) GetSupportedProtocols() []ServiceProtocol {
	if m != nil {
		return m.SupportedProtocols
	}
	return nil
}

func (m *ServiceEndpoint) GetRoutingKeys() []string {
	if m != nil {
		return m.RoutingKeys
	}
	return nil
}

// VerificationMethod is a method that can be used to verify the DID.
type VerificationMethod struct {
	// ID is the DID of the verification method.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Type is the type of the verification method.
	Type VerificationMethod_Type `protobuf:"varint,2,opt,name=type,proto3,enum=sonrio.sonr.registry.VerificationMethod_Type" json:"type,omitempty"`
	// Controller is the DID of the controller of the verification method.
	Controller string `protobuf:"bytes,3,opt,name=controller,proto3" json:"controller,omitempty"`
	// PublicKeyHex is the public key of the verification method in hexidecimal.
	PublicKeyHex string `protobuf:"bytes,4,opt,name=public_key_hex,json=publicKeyHex,proto3" json:"public_key_hex,omitempty"`
	// PublicKeyBase58 is the public key of the verification method in base58.
	PublicKeyBase58 string `protobuf:"bytes,5,opt,name=public_key_base58,json=publicKeyBase58,proto3" json:"public_key_base58,omitempty"`
	// BlockchainAccountId is the blockchain account id of the verification method.
	BlockchainAccountId string `protobuf:"bytes,6,opt,name=blockchain_account_id,json=blockchainAccountId,proto3" json:"blockchain_account_id,omitempty"`
	// PublicKeyJwk is the public key of the verification method in JWK format.
	PublicKeyJwk map[string]string `protobuf:"bytes,7,rep,name=public_key_jwk,json=publicKeyJwk,proto3" json:"public_key_jwk,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VerificationMethod) Reset()         { *m = VerificationMethod{} }
func (m *VerificationMethod) String() string { return proto.CompactTextString(m) }
func (*VerificationMethod) ProtoMessage()    {}
func (*VerificationMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_36cc9cb5bc1486a2, []int{4}
}
func (m *VerificationMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerificationMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerificationMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerificationMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerificationMethod.Merge(m, src)
}
func (m *VerificationMethod) XXX_Size() int {
	return m.Size()
}
func (m *VerificationMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_VerificationMethod.DiscardUnknown(m)
}

var xxx_messageInfo_VerificationMethod proto.InternalMessageInfo

func (m *VerificationMethod) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VerificationMethod) GetType() VerificationMethod_Type {
	if m != nil {
		return m.Type
	}
	return VerificationMethod_TYPE_UNSPECIFIED
}

func (m *VerificationMethod) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyHex() string {
	if m != nil {
		return m.PublicKeyHex
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyBase58() string {
	if m != nil {
		return m.PublicKeyBase58
	}
	return ""
}

func (m *VerificationMethod) GetBlockchainAccountId() string {
	if m != nil {
		return m.BlockchainAccountId
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyJwk() map[string]string {
	if m != nil {
		return m.PublicKeyJwk
	}
	return nil
}

func init() {
	proto.RegisterEnum("sonrio.sonr.registry.NetworkType", NetworkType_name, NetworkType_value)
	proto.RegisterEnum("sonrio.sonr.registry.ServiceProtocol", ServiceProtocol_name, ServiceProtocol_value)
	proto.RegisterEnum("sonrio.sonr.registry.ServiceType", ServiceType_name, ServiceType_value)
	proto.RegisterEnum("sonrio.sonr.registry.VerificationMethod_Type", VerificationMethod_Type_name, VerificationMethod_Type_value)
	proto.RegisterType((*Did)(nil), "sonrio.sonr.registry.Did")
	proto.RegisterType((*DidDocument)(nil), "sonrio.sonr.registry.DidDocument")
	proto.RegisterMapType((map[string]string)(nil), "sonrio.sonr.registry.DidDocument.MetadataEntry")
	proto.RegisterType((*Service)(nil), "sonrio.sonr.registry.Service")
	proto.RegisterMapType((map[string]string)(nil), "sonrio.sonr.registry.Service.MetadataEntry")
	proto.RegisterType((*ServiceEndpoint)(nil), "sonrio.sonr.registry.ServiceEndpoint")
	proto.RegisterType((*VerificationMethod)(nil), "sonrio.sonr.registry.VerificationMethod")
	proto.RegisterMapType((map[string]string)(nil), "sonrio.sonr.registry.VerificationMethod.PublicKeyJwkEntry")
}

func init() { proto.RegisterFile("registry/did.proto", fileDescriptor_36cc9cb5bc1486a2) }

var fileDescriptor_36cc9cb5bc1486a2 = []byte{
	// 1120 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x52, 0xdb, 0xd6,
	0x17, 0x46, 0xb6, 0xf9, 0x93, 0x63, 0x63, 0xc4, 0x05, 0x12, 0x0d, 0xe1, 0xe7, 0x10, 0xf2, 0x4b,
	0x87, 0xd2, 0x89, 0x09, 0x66, 0x68, 0x69, 0xba, 0xe8, 0xc8, 0x96, 0x42, 0x8c, 0xb1, 0xec, 0x91,
	0x04, 0x29, 0xdd, 0xdc, 0xca, 0xd2, 0x8d, 0xad, 0xda, 0x48, 0xae, 0x74, 0x0d, 0xe8, 0x29, 0xda,
	0x97, 0xe8, 0x4c, 0x37, 0x5d, 0xf4, 0x2d, 0xba, 0xe9, 0x4c, 0x96, 0x5d, 0x76, 0xa0, 0x6f, 0xd1,
	0x4d, 0x47, 0x57, 0xb2, 0xf1, 0xbf, 0xa1, 0xe9, 0xa2, 0x2b, 0xf9, 0x7c, 0xdf, 0x77, 0x8f, 0xce,
	0x3d, 0xfa, 0xce, 0x19, 0x03, 0xf2, 0x48, 0xd3, 0xf6, 0xa9, 0x17, 0xec, 0x5a, 0xb6, 0x95, 0xef,
	0x7a, 0x2e, 0x75, 0xd1, 0xaa, 0xef, 0x3a, 0x9e, 0xed, 0xe6, 0xc3, 0x47, 0xbe, 0xcf, 0x6f, 0x7d,
	0xcf, 0x41, 0x52, 0xb2, 0x2d, 0xf4, 0x10, 0xe6, 0x2e, 0x08, 0x6d, 0xb9, 0x96, 0xc0, 0x6d, 0x72,
	0xdb, 0x0f, 0xd4, 0x38, 0x42, 0x02, 0xcc, 0x3b, 0x84, 0x5e, 0xb9, 0x5e, 0x5b, 0x48, 0x30, 0xa2,
	0x1f, 0xa2, 0x2c, 0x24, 0x6c, 0x4b, 0x48, 0x32, 0x30, 0x61, 0x5b, 0x68, 0x15, 0x66, 0xbb, 0x06,
	0x6d, 0xf9, 0x42, 0x6a, 0x33, 0xb9, 0xfd, 0x40, 0x8d, 0x82, 0x10, 0xfd, 0xae, 0x47, 0xbc, 0x40,
	0x98, 0x65, 0xc2, 0x28, 0x40, 0xeb, 0xb0, 0xf0, 0xce, 0x33, 0x9a, 0x17, 0xc4, 0xa1, 0xc2, 0x1c,
	0x23, 0x06, 0xf1, 0xd6, 0x5f, 0x29, 0x48, 0x4b, 0xb6, 0x25, 0xb9, 0x66, 0x2f, 0x8c, 0xc3, 0x0a,
	0x4c, 0xd7, 0xa1, 0xe4, 0x9a, 0x0a, 0x1c, 0xcb, 0xdc, 0x0f, 0xe3, 0x0a, 0x12, 0x83, 0x0a, 0x72,
	0x00, 0x21, 0xe5, 0xb9, 0x9d, 0x0e, 0xf1, 0x84, 0x24, 0x13, 0x0f, 0x21, 0xe8, 0x1c, 0x56, 0x2e,
	0x89, 0x67, 0xbf, 0xb3, 0x4d, 0x83, 0xda, 0xae, 0x83, 0xe3, 0x0b, 0x87, 0xf5, 0xa6, 0x0b, 0xdb,
	0xf9, 0x69, 0xfd, 0xc9, 0x9f, 0x0d, 0x1d, 0xa8, 0x32, 0xbd, 0x8a, 0x2e, 0x27, 0x30, 0xf4, 0x11,
	0x64, 0x8d, 0x1e, 0x6d, 0x11, 0x87, 0xc6, 0xb8, 0x30, 0xcb, 0x5e, 0x3f, 0x86, 0xa2, 0x8f, 0x81,
	0x37, 0x7c, 0x9f, 0x78, 0xc3, 0xef, 0x9f, 0x63, 0xca, 0xa5, 0x01, 0x1e, 0xa7, 0xdc, 0x87, 0x35,
	0xd3, 0xe8, 0x1a, 0x0d, 0xbb, 0x63, 0xd3, 0x00, 0xdb, 0xce, 0xa5, 0x1b, 0x67, 0x9e, 0x67, 0xfa,
	0xd5, 0x3b, 0xb2, 0x3c, 0xe0, 0xc6, 0x0e, 0x59, 0xa4, 0x43, 0x9a, 0xd1, 0xa1, 0x85, 0xf1, 0x43,
	0xd2, 0x80, 0x43, 0xcf, 0x60, 0xb1, 0x4d, 0x02, 0x6c, 0x34, 0x3d, 0x42, 0xd8, 0x27, 0x79, 0xc0,
	0xc4, 0x99, 0x36, 0x09, 0xc4, 0x3e, 0x86, 0x3e, 0x83, 0x79, 0x9f, 0x78, 0x97, 0xb6, 0x49, 0x04,
	0x60, 0x0d, 0xfb, 0xdf, 0xf4, 0x86, 0x69, 0x91, 0x48, 0xed, 0xab, 0xd1, 0x16, 0x2c, 0x1a, 0x1d,
	0xdf, 0xc5, 0x6d, 0xc7, 0xbd, 0x72, 0xb0, 0xe1, 0x0b, 0x69, 0x96, 0x3d, 0x1d, 0x82, 0x95, 0x10,
	0x13, 0x7d, 0x54, 0x81, 0x85, 0x0b, 0x42, 0x0d, 0xcb, 0xa0, 0x86, 0x90, 0x61, 0xd9, 0x77, 0xa7,
	0x67, 0x1f, 0x32, 0x46, 0xbe, 0x1a, 0x9f, 0x90, 0x1d, 0xea, 0x05, 0xea, 0x20, 0xc1, 0xfa, 0x17,
	0xb0, 0x38, 0x42, 0x21, 0x1e, 0x92, 0x6d, 0x12, 0xc4, 0xc6, 0x0e, 0x7f, 0x86, 0xae, 0xbc, 0x34,
	0x3a, 0x3d, 0x12, 0x9b, 0x27, 0x0a, 0x5e, 0x25, 0x0e, 0xb9, 0xad, 0x9f, 0x12, 0x30, 0x1f, 0x5f,
	0x21, 0xf6, 0x17, 0x37, 0xf0, 0xd7, 0x01, 0xa4, 0x68, 0xd0, 0x8d, 0x0e, 0x65, 0x0b, 0x4f, 0xef,
	0xbd, 0xbf, 0x1e, 0x74, 0x89, 0xca, 0xe4, 0xa8, 0x0e, 0x7c, 0xdc, 0x0b, 0x4c, 0x1c, 0xab, 0xeb,
	0xda, 0x0e, 0x65, 0x63, 0x93, 0x2e, 0x3c, 0xbf, 0x37, 0x85, 0x1c, 0x8b, 0xd5, 0x25, 0x7f, 0x14,
	0x40, 0x47, 0x43, 0xed, 0x8a, 0xdc, 0xfb, 0xc9, 0xbd, 0x99, 0xfe, 0x9b, 0x56, 0xfd, 0xc6, 0xc1,
	0xd2, 0x58, 0xa9, 0xe8, 0x39, 0x64, 0xa9, 0x67, 0x38, 0x7e, 0xd7, 0xf5, 0x28, 0x66, 0xcd, 0x8a,
	0x52, 0x2d, 0x0e, 0xd0, 0xb0, 0x31, 0xf7, 0x6c, 0x95, 0x33, 0x58, 0xf1, 0x7b, 0xdd, 0x50, 0x48,
	0x2c, 0xcc, 0x16, 0x97, 0xe9, 0x76, 0x7c, 0x36, 0xcc, 0xd9, 0x7f, 0xe8, 0x57, 0x3d, 0x56, 0xab,
	0x68, 0x90, 0xa1, 0x0f, 0xf9, 0xe8, 0x29, 0x64, 0x3c, 0xb7, 0x47, 0x6d, 0xa7, 0x89, 0xdb, 0x24,
	0xe8, 0x2f, 0xa9, 0x74, 0x8c, 0x55, 0x48, 0xe0, 0x6f, 0xfd, 0x99, 0x02, 0x34, 0x39, 0xee, 0x13,
	0x2e, 0x10, 0x47, 0x5c, 0xf0, 0xe2, 0x43, 0xd7, 0x46, 0x7e, 0xc8, 0x11, 0xe3, 0x8b, 0x8a, 0x1b,
	0x5b, 0x54, 0xff, 0x87, 0x6c, 0xb7, 0xd7, 0xe8, 0xd8, 0x66, 0x58, 0x2b, 0x6e, 0x91, 0x6b, 0x21,
	0xc5, 0x34, 0x99, 0x08, 0xad, 0x90, 0xe0, 0x0d, 0xb9, 0x46, 0x3b, 0xb0, 0x3c, 0xa4, 0x6a, 0x18,
	0x3e, 0x39, 0x38, 0x8c, 0xd7, 0xec, 0xd2, 0x40, 0x58, 0x64, 0x30, 0x2a, 0xc0, 0x5a, 0xa3, 0xe3,
	0x9a, 0x6d, 0xb3, 0x65, 0xd8, 0x0e, 0x36, 0x4c, 0xd3, 0xed, 0x39, 0x14, 0xdb, 0x56, 0xbc, 0x7d,
	0x57, 0xee, 0x48, 0x31, 0xe2, 0xca, 0x16, 0xfa, 0x66, 0xa4, 0x8a, 0x6f, 0xaf, 0xda, 0x6c, 0xf3,
	0xa4, 0x0b, 0xaf, 0x3e, 0xf8, 0xca, 0xf5, 0x7e, 0x15, 0xc7, 0x57, 0xed, 0xc8, 0x7a, 0x77, 0x37,
	0x38, 0xbe, 0x6a, 0xaf, 0x7f, 0x09, 0xcb, 0x13, 0x92, 0x7f, 0x65, 0xc1, 0x5f, 0x38, 0x48, 0x31,
	0x43, 0xad, 0x02, 0xaf, 0x9f, 0xd7, 0x65, 0x7c, 0xaa, 0x68, 0x75, 0xb9, 0x54, 0x7e, 0x5d, 0x96,
	0x25, 0x7e, 0x06, 0x09, 0xb0, 0xca, 0x50, 0xb9, 0x24, 0x69, 0x22, 0xd6, 0xe4, 0x52, 0xbd, 0x70,
	0xf0, 0x69, 0x65, 0x8f, 0xe7, 0xd0, 0x12, 0xa4, 0x19, 0xf3, 0x55, 0xe1, 0xe0, 0x60, 0xef, 0x73,
	0x3e, 0x81, 0x78, 0xc8, 0x44, 0x52, 0x29, 0x42, 0x92, 0x68, 0x0d, 0x96, 0x19, 0x52, 0x3c, 0xd1,
	0xf0, 0x5e, 0x61, 0xff, 0x70, 0x0f, 0x1f, 0xed, 0xf1, 0xa9, 0x69, 0x70, 0x81, 0x9f, 0x45, 0x19,
	0x58, 0x60, 0xb0, 0xaa, 0x89, 0xfc, 0x1c, 0x5a, 0x87, 0x87, 0x2c, 0x3a, 0xd6, 0x6a, 0x0a, 0x7e,
	0x2b, 0x17, 0x71, 0x45, 0x3e, 0xc7, 0x85, 0x97, 0x85, 0x97, 0xfc, 0xfc, 0xce, 0x35, 0xa4, 0x95,
	0xc8, 0xec, 0xac, 0xf2, 0x0d, 0x10, 0x14, 0x59, 0x7f, 0x5b, 0x53, 0x2b, 0x78, 0xfa, 0x0d, 0x46,
	0xd8, 0xaa, 0x58, 0x56, 0x14, 0x59, 0xe7, 0xb9, 0x09, 0x46, 0x97, 0x35, 0x3d, 0x64, 0x12, 0xe8,
	0x11, 0xac, 0x8c, 0x30, 0x92, 0x7c, 0x16, 0x12, 0xc9, 0x9d, 0x9f, 0xef, 0x06, 0xb6, 0x3f, 0x18,
	0x68, 0x13, 0x36, 0x34, 0x59, 0x3d, 0x2b, 0x97, 0x64, 0x5c, 0x57, 0x6b, 0x7a, 0xad, 0x54, 0x3b,
	0x19, 0x2b, 0x61, 0x03, 0x84, 0x09, 0x45, 0xf1, 0xb4, 0x54, 0x91, 0x75, 0x8d, 0xe7, 0xa6, 0xb2,
	0xa5, 0x37, 0xa2, 0xa2, 0xc8, 0x27, 0x7c, 0x62, 0x2a, 0x5b, 0x2b, 0x1e, 0xcb, 0x25, 0x5d, 0xe3,
	0x93, 0x28, 0x07, 0xeb, 0x13, 0xec, 0xeb, 0x53, 0xa5, 0xa4, 0x97, 0x6b, 0x8a, 0xc6, 0xa7, 0x76,
	0x7e, 0xe4, 0x20, 0x3d, 0xb4, 0x4e, 0x87, 0xb3, 0x4d, 0x69, 0xd5, 0x33, 0x78, 0x32, 0xc2, 0x4a,
	0x65, 0x09, 0x97, 0x6a, 0xd5, 0x2a, 0xae, 0xca, 0x9a, 0x26, 0x1e, 0x95, 0x95, 0x23, 0x9e, 0x43,
	0x4f, 0xe0, 0xf1, 0x88, 0xe8, 0xa4, 0xac, 0x54, 0x64, 0x09, 0x4b, 0xb5, 0xb0, 0xb1, 0x1a, 0x9f,
	0x08, 0x3f, 0xef, 0x88, 0x40, 0xab, 0x29, 0x2a, 0x9f, 0x44, 0x8f, 0xe1, 0xd1, 0x68, 0x72, 0x51,
	0x17, 0xf1, 0x99, 0x78, 0x7a, 0xa2, 0xf3, 0xa9, 0x62, 0xf1, 0xd7, 0x9b, 0x1c, 0xf7, 0xfe, 0x26,
	0xc7, 0xfd, 0x71, 0x93, 0xe3, 0x7e, 0xb8, 0xcd, 0xcd, 0xbc, 0xbf, 0xcd, 0xcd, 0xfc, 0x7e, 0x9b,
	0x9b, 0xf9, 0x7a, 0xbb, 0x69, 0xd3, 0x56, 0xaf, 0x91, 0x37, 0xdd, 0x8b, 0xdd, 0x70, 0x5a, 0x5e,
	0xd8, 0x2e, 0x7b, 0xee, 0x5e, 0xef, 0x0e, 0xfe, 0xa1, 0x85, 0x1b, 0xc1, 0x6f, 0xcc, 0xb1, 0x5d,
	0xb7, 0xff, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfd, 0x27, 0x05, 0xb8, 0xba, 0x09, 0x00, 0x00,
}

func (m *Did) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Did) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Did) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fragment) > 0 {
		i -= len(m.Fragment)
		copy(dAtA[i:], m.Fragment)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Fragment)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DidDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DidDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DidDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDid(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDid(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDid(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for iNdEx := len(m.AlsoKnownAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlsoKnownAs[iNdEx])
			copy(dAtA[i:], m.AlsoKnownAs[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.AlsoKnownAs[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Service) > 0 {
		for iNdEx := len(m.Service) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Service[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDid(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.KeyAgreement) > 0 {
		for iNdEx := len(m.KeyAgreement) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyAgreement[iNdEx])
			copy(dAtA[i:], m.KeyAgreement[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.KeyAgreement[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CapabilityDelegation) > 0 {
		for iNdEx := len(m.CapabilityDelegation) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapabilityDelegation[iNdEx])
			copy(dAtA[i:], m.CapabilityDelegation[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.CapabilityDelegation[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CapabilityInvocation) > 0 {
		for iNdEx := len(m.CapabilityInvocation) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapabilityInvocation[iNdEx])
			copy(dAtA[i:], m.CapabilityInvocation[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.CapabilityInvocation[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AssertionMethod) > 0 {
		for iNdEx := len(m.AssertionMethod) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AssertionMethod[iNdEx])
			copy(dAtA[i:], m.AssertionMethod[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.AssertionMethod[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Authentication) > 0 {
		for iNdEx := len(m.Authentication) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Authentication[iNdEx])
			copy(dAtA[i:], m.Authentication[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.Authentication[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.VerificationMethod) > 0 {
		for iNdEx := len(m.VerificationMethod) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VerificationMethod[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDid(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Controller) > 0 {
		for iNdEx := len(m.Controller) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Controller[iNdEx])
			copy(dAtA[i:], m.Controller[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.Controller[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Context) > 0 {
		for iNdEx := len(m.Context) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Context[iNdEx])
			copy(dAtA[i:], m.Context[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.Context[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDid(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDid(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDid(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ServiceEndpoint != nil {
		{
			size, err := m.ServiceEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintDid(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoutingKeys) > 0 {
		for iNdEx := len(m.RoutingKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RoutingKeys[iNdEx])
			copy(dAtA[i:], m.RoutingKeys[iNdEx])
			i = encodeVarintDid(dAtA, i, uint64(len(m.RoutingKeys[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SupportedProtocols) > 0 {
		dAtA3 := make([]byte, len(m.SupportedProtocols)*10)
		var j2 int
		for _, num := range m.SupportedProtocols {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintDid(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransportType) > 0 {
		i -= len(m.TransportType)
		copy(dAtA[i:], m.TransportType)
		i = encodeVarintDid(dAtA, i, uint64(len(m.TransportType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerificationMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerificationMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerificationMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKeyJwk) > 0 {
		for k := range m.PublicKeyJwk {
			v := m.PublicKeyJwk[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDid(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDid(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDid(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BlockchainAccountId) > 0 {
		i -= len(m.BlockchainAccountId)
		copy(dAtA[i:], m.BlockchainAccountId)
		i = encodeVarintDid(dAtA, i, uint64(len(m.BlockchainAccountId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PublicKeyBase58) > 0 {
		i -= len(m.PublicKeyBase58)
		copy(dAtA[i:], m.PublicKeyBase58)
		i = encodeVarintDid(dAtA, i, uint64(len(m.PublicKeyBase58)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicKeyHex) > 0 {
		i -= len(m.PublicKeyHex)
		copy(dAtA[i:], m.PublicKeyHex)
		i = encodeVarintDid(dAtA, i, uint64(len(m.PublicKeyHex)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintDid(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDid(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDid(dAtA []byte, offset int, v uint64) int {
	offset -= sovDid(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Did) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	l = len(m.Fragment)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	return n
}

func (m *DidDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Context) > 0 {
		for _, s := range m.Context {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	if len(m.Controller) > 0 {
		for _, s := range m.Controller {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.VerificationMethod) > 0 {
		for _, e := range m.VerificationMethod {
			l = e.Size()
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.Authentication) > 0 {
		for _, s := range m.Authentication {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.AssertionMethod) > 0 {
		for _, s := range m.AssertionMethod {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.CapabilityInvocation) > 0 {
		for _, s := range m.CapabilityInvocation {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.CapabilityDelegation) > 0 {
		for _, s := range m.CapabilityDelegation {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.KeyAgreement) > 0 {
		for _, s := range m.KeyAgreement {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.Service) > 0 {
		for _, e := range m.Service {
			l = e.Size()
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for _, s := range m.AlsoKnownAs {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDid(uint64(len(k))) + 1 + len(v) + sovDid(uint64(len(v)))
			n += mapEntrySize + 1 + sovDid(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDid(uint64(m.Type))
	}
	if m.ServiceEndpoint != nil {
		l = m.ServiceEndpoint.Size()
		n += 1 + l + sovDid(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDid(uint64(len(k))) + 1 + len(v) + sovDid(uint64(len(v)))
			n += mapEntrySize + 1 + sovDid(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ServiceEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransportType)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	if len(m.SupportedProtocols) > 0 {
		l = 0
		for _, e := range m.SupportedProtocols {
			l += sovDid(uint64(e))
		}
		n += 1 + sovDid(uint64(l)) + l
	}
	if len(m.RoutingKeys) > 0 {
		for _, s := range m.RoutingKeys {
			l = len(s)
			n += 1 + l + sovDid(uint64(l))
		}
	}
	return n
}

func (m *VerificationMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDid(uint64(m.Type))
	}
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	l = len(m.PublicKeyHex)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	l = len(m.PublicKeyBase58)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	l = len(m.BlockchainAccountId)
	if l > 0 {
		n += 1 + l + sovDid(uint64(l))
	}
	if len(m.PublicKeyJwk) > 0 {
		for k, v := range m.PublicKeyJwk {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDid(uint64(len(k))) + 1 + len(v) + sovDid(uint64(len(v)))
			n += mapEntrySize + 1 + sovDid(uint64(mapEntrySize))
		}
	}
	return n
}

func sovDid(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDid(x uint64) (n int) {
	return sovDid(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Did) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Did: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Did: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fragment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DidDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DidDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DidDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = append(m.Controller, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationMethod = append(m.VerificationMethod, &VerificationMethod{})
			if err := m.VerificationMethod[len(m.VerificationMethod)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authentication = append(m.Authentication, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssertionMethod = append(m.AssertionMethod, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapabilityInvocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapabilityInvocation = append(m.CapabilityInvocation, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapabilityDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapabilityDelegation = append(m.CapabilityDelegation, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAgreement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAgreement = append(m.KeyAgreement, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = append(m.Service, &Service{})
			if err := m.Service[len(m.Service)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlsoKnownAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlsoKnownAs = append(m.AlsoKnownAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDid
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDid
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDid
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDid
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDid(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDid
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ServiceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceEndpoint == nil {
				m.ServiceEndpoint = &ServiceEndpoint{}
			}
			if err := m.ServiceEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDid
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDid
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDid
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDid
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDid(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDid
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v ServiceProtocol
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ServiceProtocol(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedProtocols = append(m.SupportedProtocols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDid
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDid
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SupportedProtocols) == 0 {
					m.SupportedProtocols = make([]ServiceProtocol, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ServiceProtocol
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ServiceProtocol(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedProtocols = append(m.SupportedProtocols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedProtocols", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKeys = append(m.RoutingKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerificationMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerificationMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerificationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VerificationMethod_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyHex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyHex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBase58", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyBase58 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockchainAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockchainAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyJwk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKeyJwk == nil {
				m.PublicKeyJwk = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDid
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDid
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDid
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDid
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDid(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDid
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PublicKeyJwk[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDid(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDid
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDid
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDid
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDid
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDid        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDid          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDid = fmt.Errorf("proto: unexpected end of group")
)
